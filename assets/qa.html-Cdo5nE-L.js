import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as p,o as s}from"./app-DAvQOTm3.js";const i={};function l(o,t){return s(),a("div",null,t[0]||(t[0]=[p('<h1 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题"><span>常见问题</span></a></h1><h2 id="声明的http接口为什么要继承ihttpapi接口" tabindex="-1"><a class="header-anchor" href="#声明的http接口为什么要继承ihttpapi接口"><span>声明的http接口为什么要继承IHttpApi接口？</span></a></h2><p>一是为了方便WebApiClient库自动生成接口的代理类，相当用于标记作用；二是继承了<code>IHttpApi</code>接口，http接口代理类实例就有Dispose方法。</p><h2 id="http接口可以继承其它http接口吗" tabindex="-1"><a class="header-anchor" href="#http接口可以继承其它http接口吗"><span>http接口可以继承其它http接口吗？</span></a></h2><p>可以继承，父接口的相关方法也都当作Api方法，需要注意的是，父接口的方法的接口级特性将失效，而是应用了子接口的接口级特性，所以为了方便理解，最好不要这样继承。</p><h2 id="使用-proxyattribute-host-port-代理特性前-怎么验证代理的有效性" tabindex="-1"><a class="header-anchor" href="#使用-proxyattribute-host-port-代理特性前-怎么验证代理的有效性"><span>使用<code>[ProxyAttribute(host,port)]</code>代理特性前，怎么验证代理的有效性？</span></a></h2><p>可以使用ProxyValidator对象的Validate方法来验证代理的有效性。</p><h2 id="为什么不支持将接口方法的返回类型声明为task对象而必须为task-或itask" tabindex="-1"><a class="header-anchor" href="#为什么不支持将接口方法的返回类型声明为task对象而必须为task-或itask"><span>为什么不支持将接口方法的返回类型声明为<code>Task</code>对象而必须为<code>Task&lt;&gt;</code>或<code>ITask&lt;&gt;</code>？</span></a></h2><p>这个是设计的原则，因为不管开发者关不关注返回值，Http请求要么有响应要么抛出异常，如果你不关注结果的解析，可以声明为<code>Task&lt;HttpResponseMessage&gt;</code>而不去解析<code>HttpResponseMessage</code>就可以。</p><h2 id="使用webapiclient怎么下载文件" tabindex="-1"><a class="header-anchor" href="#使用webapiclient怎么下载文件"><span>使用WebApiClient怎么下载文件？</span></a></h2><p>你应该将接口返回类型声明为<code>ITask&lt;HttpResponseFile&gt;</code>。</p><h2 id="接口返回类型除了声明为itask-httpresponsemessage-还可以声明哪些抽象的返回类型" tabindex="-1"><a class="header-anchor" href="#接口返回类型除了声明为itask-httpresponsemessage-还可以声明哪些抽象的返回类型"><span>接口返回类型除了声明为<code>ITask&lt;HttpResponseMessage&gt;</code>，还可以声明哪些抽象的返回类型？</span></a></h2><p>还可以声明为<code>ITask&lt;string&gt;</code>、<code>ITask&lt;Stream&gt;</code>和<code>ITask&lt;Byte[]&gt;</code>，这些都是抽象的返回类型。</p><h2 id="接口声明的参数可以为object或某些类型的基类吗" tabindex="-1"><a class="header-anchor" href="#接口声明的参数可以为object或某些类型的基类吗"><span>接口声明的参数可以为Object或某些类型的基类吗？</span></a></h2><p>可以这样声明，数据还是子类的，但xml序列化会有问题，一般情况下，建议严格按照服务器的具体类型来声明参数。</p><h2 id="webapiclient怎么使用同步请求" tabindex="-1"><a class="header-anchor" href="#webapiclient怎么使用同步请求"><span>WebApiClient怎么使用同步请求</span></a></h2><p>WebApiClient是对HttpClient的封包，HttpClient没有提供相关的同步请求方法，所以WebApiClient也没有同步请求，不正确的阻塞ITask和Task返回值，在一些环境下很容易死锁。</p>',17)]))}const r=e(i,[["render",l],["__file","qa.html.vue"]]),c=JSON.parse('{"path":"/old/qa.html","title":"常见问题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"声明的http接口为什么要继承IHttpApi接口？","slug":"声明的http接口为什么要继承ihttpapi接口","link":"#声明的http接口为什么要继承ihttpapi接口","children":[]},{"level":2,"title":"http接口可以继承其它http接口吗？","slug":"http接口可以继承其它http接口吗","link":"#http接口可以继承其它http接口吗","children":[]},{"level":2,"title":"使用[ProxyAttribute(host,port)]代理特性前，怎么验证代理的有效性？","slug":"使用-proxyattribute-host-port-代理特性前-怎么验证代理的有效性","link":"#使用-proxyattribute-host-port-代理特性前-怎么验证代理的有效性","children":[]},{"level":2,"title":"为什么不支持将接口方法的返回类型声明为Task对象而必须为Task<>或ITask<>？","slug":"为什么不支持将接口方法的返回类型声明为task对象而必须为task-或itask","link":"#为什么不支持将接口方法的返回类型声明为task对象而必须为task-或itask","children":[]},{"level":2,"title":"使用WebApiClient怎么下载文件？","slug":"使用webapiclient怎么下载文件","link":"#使用webapiclient怎么下载文件","children":[]},{"level":2,"title":"接口返回类型除了声明为ITask<HttpResponseMessage>，还可以声明哪些抽象的返回类型？","slug":"接口返回类型除了声明为itask-httpresponsemessage-还可以声明哪些抽象的返回类型","link":"#接口返回类型除了声明为itask-httpresponsemessage-还可以声明哪些抽象的返回类型","children":[]},{"level":2,"title":"接口声明的参数可以为Object或某些类型的基类吗？","slug":"接口声明的参数可以为object或某些类型的基类吗","link":"#接口声明的参数可以为object或某些类型的基类吗","children":[]},{"level":2,"title":"WebApiClient怎么使用同步请求","slug":"webapiclient怎么使用同步请求","link":"#webapiclient怎么使用同步请求","children":[]}],"git":{"createdTime":1680887165000,"updatedTime":1718326650000,"contributors":[{"name":"Ezreal","email":"memory_of_you@hotmail.com","commits":1},{"name":"陈国伟","email":"366193849@qq.com","commits":1}]},"readingTime":{"minutes":1.62,"words":485},"filePathRelative":"old/qa.md","localizedDate":"2023年4月7日","excerpt":"\\n<h2>声明的http接口为什么要继承IHttpApi接口？</h2>\\n<p>一是为了方便WebApiClient库自动生成接口的代理类，相当用于标记作用；二是继承了<code>IHttpApi</code>接口，http接口代理类实例就有Dispose方法。</p>\\n<h2>http接口可以继承其它http接口吗？</h2>\\n<p>可以继承，父接口的相关方法也都当作Api方法，需要注意的是，父接口的方法的接口级特性将失效，而是应用了子接口的接口级特性，所以为了方便理解，最好不要这样继承。</p>\\n<h2>使用<code>[ProxyAttribute(host,port)]</code>代理特性前，怎么验证代理的有效性？</h2>"}');export{r as comp,c as data};
